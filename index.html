<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Kaka Onge - Creative Developer</title>
  <link href="https://fonts.googleapis.com/css2?family=Poppins:wght@300;400;600;700&display=swap" rel="stylesheet">
  <link rel="icon" href="favicon.ico" type="image/x-icon">
  <style>
    /* ---------- Global & splash (three.js background) ---------- */
    * { margin: 0; padding: 0; box-sizing: border-box; }
    body {
      font-family: 'Poppins', sans-serif;
      margin: 0;
      height: 100vh;
      overflow: hidden;
      /* dark background for the 3D splash */
      background: radial-gradient(1200px 600px at 70% 20%, #2a2b55 0%, transparent 60%),
                  radial-gradient(1200px 800px at 30% 80%, #181a38 0%, transparent 60%),
                  linear-gradient(160deg, #0f1020, #1a1b3a);
      color: black;
    }

    /* SPLASH that contains the three.js canvas */
    #splash {
      position: fixed;
      inset: 0;
      display: flex;
      justify-content: center;
      align-items: center;
      z-index: 9999;
      background: transparent; /* canvas provides the visuals */
      /* enable smooth zoom-out transform + opacity */
      transition: transform 0.85s cubic-bezier(.2,.9,.2,1), opacity 0.85s ease, visibility 0.85s;
      transform-origin: center center;
      opacity: 1;
      visibility: visible;
      pointer-events: auto;
    }
    /* applied when removing splash: shrinks & fades, revealing content underneath */
    #splash.zoom-away {
      transform: scale(0.12) translateY(-18vh);
      opacity: 0;
      visibility: hidden;
      pointer-events: none;
    }

    #splash #app { position: absolute; inset: 0; z-index: 1; }

    /* splash branding (scoped to #splash to avoid conflicts) */
    #splash .branding {
      position: fixed;
      top: 20px;
      left: 50%;
      transform: translateX(-50%);
      font-family: Poppins, sans-serif;
      font-size: 28px;
      font-weight: 700;
      color: #ffffff;
      letter-spacing: 1px;
      text-shadow: 0 0 12px rgba(255,255,255,0.5);
      z-index: 10;
    }

    /* ---------- Portfolio content (kept from your original code, now visible underneath) ---------- */
    #content {
      /* initially visible but hidden by splash (opacity:0) */
      display: flex;
      flex-direction: column;
      width: 100%;
      min-height: 100vh;
      overflow-x: hidden;
      background: #ffcc00; /* original yellow background */
      color: black;
      line-height: 1.6;
      opacity: 0;
      transition: opacity 0.9s ease, transform 0.9s ease;
      transform: translateY(8px);
    }

    /* Header and branding in portfolio (scoped) */
    #content header {
      display: flex;
      justify-content: space-between;
      align-items: center;
      padding: 1.5rem 2rem;
      font-weight: 600;
      flex-wrap: wrap;
    }
    #content .branding {
      display: flex;
      align-items: center;
      gap: 10px;
    }
    #content .branding img {
      height: 40px;
      width: 40px;
      object-fit: cover;
      border-radius: 50%;
    }

    /* Main area */
    #content .main {
      padding: 2rem;
      text-align: center;
      max-width: 1000px;
      margin: 0 auto;
      flex: 1;
    }
    #content .headline {
      display: flex;
      flex-wrap: wrap;
      justify-content: center;
      align-items: center;
      gap: 0.5rem;
      font-weight: 700;
      font-size: 3rem;
      color: #b31a1a;
      animation: fadeInUp 1s ease-out forwards;
    }
    #content .designer-text {
      font-size: 2.8rem;
      color: #b31a1a;
      animation: fadeInUp 2s ease-out forwards;
      font-weight: 700;
    }
    #content .roles {
      font-size: 0.95rem;
      margin-top: 0.5rem;
      color: #444;
    }
    #content .availability {
      margin-top: 1rem;
      color: #b31a1a;
      font-weight: bold;
    }
    #content .description {
      max-width: 700px;
      margin: 2rem auto;
      font-size: 1rem;
      text-align: center;
      color: #222;
    }
    #content .buttons {
      margin-top: 2rem;
      display: flex;
      justify-content: center;
      flex-wrap: wrap;
      gap: 1rem;
    }
    #content .btn {
      background: red;
      color: #fff;
      border: none;
      padding: 0.8rem 1.5rem;
      font-size: 1rem;
      border-radius: 12px;
      cursor: pointer;
      transition: background 0.3s;
      font-weight: bold;
    }
    #content .btn:hover { background: darkred; }

    #content .socials {
      text-align: center;
      padding: 2rem 1rem;
    }
    #content .socials a {
      margin: 0 10px;
      color: black;
      font-size: 1.5rem;
      text-decoration: none;
      transition: color 0.3s;
    }
    #content .socials a:hover { color: red; }

    @keyframes fadeInUp {
      from { opacity: 0; transform: translateY(30px); }
      to { opacity: 1; transform: translateY(0); }
    }

    /* reveal animation for content after splash */
    #content.show {
      opacity: 1;
      transform: translateY(0);
    }

    /* Responsive adjustments */
    @media (max-width: 600px) {
      #content .headline { font-size: 2rem; flex-direction: column; }
      #content .designer-text { font-size: 2.2rem; }
    }
  </style>
</head>
<body>
  <!-- SPLASH (three.js Rubik's Cube) -->
  <div id="splash" aria-hidden="false">
    <div id="app"></div>
    <div class="branding">Kaka Onge — Creative Developer</div>
  </div>

  <!-- FULL portfolio content (exact content you originally provided) -->
  <div id="content" aria-hidden="true">
    <header>
      <div class="branding">
        <img src="favicon.ico" alt="Kaka Onge Logo" />
        <div>Kaka Onge</div>
      </div>
    </header>

    <main class="main">
      <div class="headline">
        <span>Creative</span>
        <span>Developer</span>
        <span>/</span>
        <span class="designer-text">Designer</span>
      </div>
      <div class="roles">Developer · UI/UX Designer · Photographer · Freelancer</div>
      <div class="availability">● Available for work</div>
      <div class="description">
        I am a developer and UI/UX designer based in Nairobi, Kenya. Are you looking for a creative developer? Then rely on me for design, development, and digital product management. As a freelancer, I also collaborate with creative agencies.
      </div>
      <div class="buttons">
        <a href="About Me.html"><button class="btn">About Kaka Onge</button></a>
        <a href="contactme.html"><button class="btn">Get in Touch</button></a>
      </div>
    </main>

    <div class="socials">
      <a href="https://x.com/Kakaonge" title="Twitter"><img src="twitter.png" width="25" height="25" alt="twitter"></a>
      <a href="https://www.instagram.com/kakaonge/" title="Instagram"><img src="instagram.png" width="25" height="25" alt="instagram"></a>
      <a href="https://ke.linkedin.com/in/kaka-onge" title="LinkedIn"><img src="linkedin.png" width="25" height="25" alt="linkedin"></a>
      <a href="https://github.com/kakaonge" title="Github"><img src="github.png" width="25" height="25" alt="github"></a>
    </div>
  </div>

  <!-- Three.js -->
  <script src="https://unpkg.com/three@0.160.0/build/three.min.js"></script>

  <!-- Rubik's Cube Script (original logic — with faster timings + zoom-away removal) -->
  <script>
    // --- constants (kept from your Rubik cube code) ---
    // ADJUSTED: make intro faster per your request
    const COLORS = { U:0xFFD500, D:0x9E9E9E, F:0x1560FF, B:0xE11D2E, R:0xE11D2E, L:0x1560FF };
    const CUBELET = 1;
    const SPEED_SCRAMBLE = 60;   // faster rotation per move (ms)
    const SPEED_SOLVE   = 80;   // faster solve moves (ms)
    const SCRAMBLE_LEN  = 14;   // fewer moves for a quick intro

    // renderer + scene + camera setup
    const app = document.getElementById('app');
    const renderer = new THREE.WebGLRenderer({ antialias:true, alpha:true });
    renderer.setPixelRatio(Math.min(devicePixelRatio, 2));
    renderer.setSize(window.innerWidth, window.innerHeight);
    app.appendChild(renderer.domElement);

    const scene = new THREE.Scene();
    scene.fog = new THREE.Fog(0x0f1020, 16, 42);

    const camera = new THREE.PerspectiveCamera(45, window.innerWidth/window.innerHeight, 0.1, 200);
    camera.position.set(6.5, 6.5, 9);
    camera.lookAt(0,0,0);

    const amb = new THREE.AmbientLight(0xffffff, 0.65); scene.add(amb);
    const key = new THREE.DirectionalLight(0xffffff, 1.1); key.position.set(6, 10, 8); scene.add(key);
    const rim = new THREE.DirectionalLight(0x88ccff, 0.6); rim.position.set(-6, -8, -10); scene.add(rim);

    // particles
    const particleGeo = new THREE.BufferGeometry();
    const PCOUNT = 400;
    const positions = new Float32Array(PCOUNT*3);
    for(let i=0;i<PCOUNT;i++){
      const r = 18 + Math.random()*18;
      const theta = Math.random()*Math.PI*2; const phi = Math.acos(2*Math.random()-1);
      positions[i*3+0] = r*Math.sin(phi)*Math.cos(theta);
      positions[i*3+1] = r*Math.cos(phi);
      positions[i*3+2] = r*Math.sin(phi)*Math.sin(theta);
    }
    particleGeo.setAttribute('position', new THREE.BufferAttribute(positions, 3));
    const particleMat = new THREE.PointsMaterial({ size:0.06, transparent:true, opacity:0.75 });
    const particles = new THREE.Points(particleGeo, particleMat); scene.add(particles);

    // cubelets
    const cubeGroup = new THREE.Group(); scene.add(cubeGroup);
    const positionsGrid = [-1, 0, 1];

    // rounded sticker helpers
    function roundedRectShape(w, h, r) {
      const hw = w/2, hh = h/2; const s = new THREE.Shape();
      s.moveTo(-hw + r, -hh);
      s.lineTo(hw - r, -hh); s.quadraticCurveTo(hw, -hh, hw, -hh + r);
      s.lineTo(hw, hh - r);  s.quadraticCurveTo(hw, hh,  hw - r, hh);
      s.lineTo(-hw + r, hh); s.quadraticCurveTo(-hw, hh, -hw, hh - r);
      s.lineTo(-hw, -hh + r); s.quadraticCurveTo(-hw, -hh, -hw + r, -hh);
      return s;
    }
    function makeRoundedStickerGeometry(size, thickness, radius){
      const shape = roundedRectShape(size, size, radius);
      const geo = new THREE.ExtrudeGeometry(shape, { depth: thickness, bevelEnabled:false, curveSegments:12 });
      geo.translate(0,0,-thickness/2); // center on Z so orientation math works
      geo.computeVertexNormals();
      return geo;
    }

    function makeCubelet(x, y, z){
      // base cubelet (slightly shrunken for gaps)
      const g = new THREE.BoxGeometry(CUBELET*0.94, CUBELET*0.94, CUBELET*0.94);
      const baseMat = new THREE.MeshStandardMaterial({ color:0x0a0a0a, metalness:0.0, roughness:0.9 });
      const mesh = new THREE.Mesh(g, baseMat);
      mesh.position.set(x, y, z);

      // very rounded, solid-color stickers
      const size = CUBELET*0.88;     // sticker size
      const thickness = 0.06;        // sticker thickness
      const radius = size * 0.24;    // corner radius (more curvy)
      const stickerGeo = makeRoundedStickerGeometry(size, thickness, radius);

      const addSticker = (color, normal) => {
        const m = new THREE.MeshStandardMaterial({ color, metalness:0.0, roughness:0.9 });
        const st = new THREE.Mesh(stickerGeo, m);
        // orient from +Z to target normal
        const axis = new THREE.Vector3(0,0,1).cross(normal).normalize();
        const angle = Math.acos(new THREE.Vector3(0,0,1).dot(normal));
        if(axis.lengthSq()>0) st.quaternion.setFromAxisAngle(axis, angle);
        // position outward on that face
        st.position.copy(normal.clone().multiplyScalar(CUBELET/2 + thickness/2 - 0.001));
        mesh.add(st);
      };

      if (y ===  1) addSticker(COLORS.U, new THREE.Vector3(0, 1, 0));
      if (y === -1) addSticker(COLORS.D, new THREE.Vector3(0,-1, 0));
      if (z ===  1) addSticker(COLORS.F, new THREE.Vector3(0, 0, 1));
      if (z === -1) addSticker(COLORS.B, new THREE.Vector3(0, 0,-1));
      if (x ===  1) addSticker(COLORS.R, new THREE.Vector3(1, 0, 0));
      if (x === -1) addSticker(COLORS.L, new THREE.Vector3(-1,0, 0));

      return mesh;
    }

    const cubelets = [];
    for (let x of positionsGrid) for (let y of positionsGrid) for (let z of positionsGrid){
      const c = makeCubelet(x, y, z);
      cubeGroup.add(c); cubelets.push(c);
    }

    const tmpGroup = new THREE.Group(); cubeGroup.add(tmpGroup);

    function selectLayer(axis, value){
      const eps = 0.001;
      return cubelets.filter(c => Math.abs(Math.round(c.position[axis]) - value) < eps+0.01);
    }

    function roundToGrid(obj){
      obj.position.set(Math.round(obj.position.x), Math.round(obj.position.y), Math.round(obj.position.z));
      const e = new THREE.Euler().setFromQuaternion(obj.quaternion);
      const snap = v => Math.round(v / (Math.PI/2)) * (Math.PI/2);
      e.set(snap(e.x), snap(e.y), snap(e.z));
      obj.quaternion.setFromEuler(e);
    }

    function rotateLayer(move, duration){
      return new Promise(resolve => {
        const axisMap = { U:'y', D:'y', R:'x', L:'x', F:'z', B:'z' };
        const layerVal = { U:1, D:-1, R:1, L:-1, F:1, B:-1 };
        const signMap = { U:1, D:-1, R:1, L:-1, F:1, B:-1 };
        const base = move[0];
        let turns = 1, dir = 1 * signMap[base];
        if (move.endsWith("2")) { turns = 2; }
        if (move.endsWith("'")) { dir *= -1; }
        const axis = axisMap[base];
        const value = layerVal[base];
        const selected = selectLayer(axis, value);
        tmpGroup.position.set(0,0,0); tmpGroup.rotation.set(0,0,0); tmpGroup.updateMatrixWorld();
        selected.forEach(c => tmpGroup.add(c));
        const start = performance.now();
        function step(now){
          const elapsed = now - start;
          const t = Math.min(elapsed / duration, 1);
          const angle = dir * t * (Math.PI/2) * turns;
          tmpGroup.rotation[axis] = angle;
          renderer.render(scene, camera);
          if (t < 1) requestAnimationFrame(step);
          else {
            selected.forEach(c => {
              c.applyMatrix4(tmpGroup.matrix);
              roundToGrid(c);
              cubeGroup.add(c);
            });
            tmpGroup.rotation.set(0,0,0);
            resolve();
          }
        }
        requestAnimationFrame(step);
      });
    }

    let tRot = 0;
    function animate(){
      tRot += 0.0035; // slightly faster ambient motion
      const r = 10.5;
      camera.position.x = r * Math.cos(tRot*0.6);
      camera.position.z = r * Math.sin(tRot*0.6);
      camera.position.y = 6.5 + Math.sin(tRot*0.9)*0.6;
      camera.lookAt(0,0,0);
      particles.rotation.y += 0.0009;
      renderer.render(scene, camera);
      requestAnimationFrame(animate);
    }

    const MOVES = ['U','D','L','R','F','B'];
    function randomScramble(n){
      const out = [];
      const opposites = { U:'D', D:'U', L:'R', R:'L', F:'B', B:'F' };
      while(out.length < n){
        const base = MOVES[(Math.random()*MOVES.length)|0];
        const suf = Math.random()<0.5 ? '' : (Math.random()<0.7 ? "'" : '2');
        const mv = base + suf;
        const prev = out[out.length-1];
        if(prev && (prev[0] === base || prev[0] === opposites[base])) continue;
        out.push(mv);
      }
      return out;
    }

    function invertMove(m){
      if(m.endsWith("2")) return m;
      if(m.endsWith("'")) return m[0];
      return m+"'";
    }

    async function performSequence(seq, speed){
      for(const m of seq){ await rotateLayer(m, speed); }
    }

    animate();

    // Run quick scramble + solve then zoom-away splash to reveal portfolio underneath
    (async () => {
      await new Promise(r => setTimeout(r, 120)); // tiny startup pause
      const scramble = randomScramble(SCRAMBLE_LEN);
      await performSequence(scramble, SPEED_SCRAMBLE);
      await new Promise(r => setTimeout(r, 120));
      const solve = [...scramble].reverse().map(invertMove);
      await performSequence(solve, SPEED_SOLVE);

      // quick delay then trigger zoom-away (shrinking) of splash so the portfolio underneath shows
      await new Promise(r => setTimeout(r, 150));
      const splash = document.getElementById('splash');
      const content = document.getElementById('content');

      // trigger CSS transform/opacity that zooms the splash away (shrinks)
      splash.classList.add('zoom-away');

      // after the CSS transition completes, hide the splash element and reveal content
      setTimeout(() => {
        try { splash.style.display = 'none'; } catch(e){}
        content.classList.add('show');
        content.setAttribute('aria-hidden', 'false');
        // restore page scrolling
        document.body.style.overflow = 'auto';
      }, 900); // matches the CSS transition duration (0.85s -> safe setTimeout 900ms)
    })();

    // handle resize
    window.addEventListener('resize', () => {
      camera.aspect = window.innerWidth / window.innerHeight;
      camera.updateProjectionMatrix();
      renderer.setSize(window.innerWidth, window.innerHeight);
    });
  </script>
</body>
</html>
